
do
  -- @name ASTRO
  hush

do
  -- @name intro
  hush
  setcps 0.9
  trbank 100
  all id
  setcps (122/120/2)
  setkey' 0 (-5) "lydian"
  setkey' 1 (-5) "lydian"
  -- once $ qtrigger 0
  --   $ (note . k 0) "~ 6 9 5 . 8 6 4 2 . 0 . ~"
  --   # amp 0.6
  --   # sus "0.2"
  --   # s "loopback" # midichan 13
  bd $ fast 2 "0 ~ ~ 0"
  sd $ fast 2 "~ 0"
  ch $ fast 2 $ "0*4"
  -- d7 $ "[[0 0 ~ 0 0 ~ 0 0 | 0 0 ~ 0 ~ 0 0 ~] . 0 ~ 0 ~ 0 ~ 0 0]"
  d7 $ fast 4 $ cat ["0*4", chop (fast 2 $ irand 4 |* 8) $ degradeBy 0.8 "~ 0"]
  d9 "[~@3 0]*2"
  s2 $ fast 2 (note $ k 0 $ "0 ~ ~ -1" |+ "[0,2]") # octave 4 # amp 0.8 # sus 0.1

do
  -- @name phrase
  s1 $ fast 2
    $ stack [
      -- midibend $ (slow 8 $ struct "t*128" $ (range 0 8192 $ sine)),
      (note . cat)
      ([ k 0 $ "~ 6 9 5 . 8 6 4 2"
       , k 0 $ "~ 1 ~ [[6, ~@2 3@3,~@3 1@2] | [6, ~ 3@4,~@3 -1@2]]@5"
       , k 0 $ "<[~ 0 ~ [5, ~@2 2@3,~@3 0@2]@5] [~ 2 ~ 4 ~ 5 ~ 6]>"
       ])
    # amp 0.5
    # sus 2]

do
  -- @name counter
  setkey' 1 2 "mixolydian"
  s4 $ fast 2 $ (note . cat)
    ([
      k 0 $ "9 9 ~ ~ ~ 5 6 8",
      k 0 $ "9 9 6 5 8 8 ~ ~",
      k 0 $ "[~ 5 6 8 | ~ [5 6 8]] . 9 9 8 6",
      k 0 $ "8 8 6 5 6 6 5 4",
      k 0 $ "5 4 2 4 -1 0 2 4",
      k 0 $ "7 7 6 7 6 6 5 4",
      k 1 $ "5 6 ~ 3 ~ 2 1 -1" |- 4,
      k 1 $ "-1 0 1 2 3 4 5 7"
     ])
    # amp 0.9
    |* sus 0.1


do
  -- @name axe
  setkey' 1 2 "mixolydian"
  -- todo: cc decay
  s1 silence
  bd $ "[0 ~@3 . 0]*2" # ccn (tr8sDecayCCArray!!0) # ccv "[0 127]*2"
  d6 $ sometimes (chop "[1@3 2]*4") "0*16" # amp ("6 4 3 6 4 3 6 7 . 3 2 7 3 2 6 2 3" |/ 16)
  sd $ "[~ 0]*2" # amp 0.5
  d7 $ "[[0 0 ~ 0 0 ~ 0 ~ | 0 0 ~ 0 ~ 0 0 ~] . 0 ~ 0 ~ 0 ~ 0 0?]"
  ch $ "0*16"
  s3 $ fast 2 $ (note . cat)
    (fmap (k 0) ["0", "0", "-1", "2", "-2", "1"]
    ++ fmap (k 1) ["-1", "0"])
    # amp 0.8
    # octave 3



setcps (120/120/2)

do
  -- @name ASTRO REPRISE
  hush 

do
  -- @name intro
  hush
  trbank 101
  all $ swingBy (1/12) 8
  setcps (92/120/2)
  setcps (86/120/2)
  setkey' 0 (-6) "lydian"
  setkey' 1 (-1) "lydian"
  setkey' 2 (-2) "mixolydian"

  mt
    $ note
    $ (|+ 12)
    $ fast 2
    $ (cat)
    (fmap (k 0)
      [ "0@5 0 ~@2" |+ 9
      , "0@5 0 ~@2" |+ 9
      , "8@5 7 ~@2"
      , "5@5 4 ~@2"
      , "2"
      , "~"
      , "~"
      , "~"
      ]
    )

    # octave 5

do
  -- @name drums
  bd $ fast 2 $ "0 ~ . [~ 0 | ~ [~ 0] | ~ 0 ~ ~]"
  sd $ fast 2 $  "~ 0"
  ch $ fast 2 $  "0*4" # amp "[0.42 0.33]*2"

do
  -- @name preface
  reface $ fast 2 $ (note . cat)
    ([ k 2 $ "2 4 5 2 4 0 4 5" |+ 2
    , k 2 $ "2 4 5 2 4 0 1 2" |+ 2
    , k 1 $ "2 3 4 2 3 0 2 4" |+ 2
    , k 1 $ "2 4 5 2 4 0 2 5" |- 2
    ]
    ++ (take 4 $ repeat (k 0 $ "2 4 5 2 4 0 2 5")))
    # octave 5
    # amp 0.6
    # sus 2
    # sustainpedal 1

do
  -- @name bassline
  lt
    $ fast 2
    $ (note . cat)
      ([ k 2 "0 2 4 7"
      , k 2 "0 2 4 7"
      , k 1 "0 2 4 6"
      , k 1 $ "-2 -1 1 4"
      ]
      ++ (take 4 $ repeat (k 0 "0 2 4 6"))
    )
    # amp 0.8

do
  -- @name drums 2
  bd $ fast 2 $ n "0 ~ . [~ 0 | ~ [~ 0] | ~ 0 ~ ~]"
  sd $ fast 2 $ n "~ 0"
  ch $ fast 8
    $ sometimes (chop 2) $ n "0"
    # amp "<0.42 0.33>"

do
  -- @name bluegrass
  s3
    $ fast 2
    $ (note . cat)
      ([ k 2 "[0 2 4 7, 14@3 13@2 14@3]"
      , k 2 "[0 2 4 7, 14@3 13@2 14@3]"
      , k 1 "[0 2 4 6, 14@3 13@2 14@3]"
      , k 1 $ "-2 -1 1 4"
      ] ++ (take 4 $ repeat (k 0 "0 2 4 6")))
    # octave 3
    # amp 0.8

do
  -- @name hold
  hush
  setF "plink" 0
  lt $ nok 0 "0(3,8) . ~@2 0@3 0@3"
    -- # octave 3
    # amp 0.7
    # sus 0.1
  mm
    $ fast 2
    $ (note . cat . fmap (+| "0@5 0 ~@2"))
    [ k 0 $ "[-2,0,2,7]" |+ 2
    , k 0 $ "[0,2,5,7]" |+ 2
    , k 0 $ "[0,2,3 4,7 5]" |+ 1
    , k 1 $ "[0,2,5 4,7 6]" |- 5
    ]
    -- # octave 5
    # amp 0.5
  ht
    $ fast 2
    -- $ sometimesBy "^plink" (# (octave (5 |+ irand 3) # sus 4))
    -- $ (note . cat . fmap (k 0) . fmap (rarely (|+ ("[1 0@3]*4" |* (irand 8) |- 4))))
    $ (nok 0 . (|+ 7) . cat)
    [ "2 4 5 2 4 0 4 5"
    , "6 8 9 6 8 -4 -2 -1"
    , "1 2 3 1 2 -1 2 5"
    ]
    # sus 1.4
    # amp 0.5

do
  -- @name drums
  bd $ n "0 . ~ 0 ~@2"
  bd $ n "[0@3 0]*2"  
  bd $ n "0 ~ ~ 0? ~ ~ 0? ~ . ~ 0 ~ [~ 0]"
  sd $ n "[~ 0]*2"
  ch $ n "0*16"

hush

do
  -- @name full
  setF "plink" 0
  setcps (90/120/2)
  bd $ "[0@3 0]*2"
  -- bd $ "0 ~ ~ 0? ~ ~ 0? ~ . ~ 0 ~ [~ 0]"
  sd $ "[~ 0]*2"
  ch $ "0*16" # amp "[0.37 0.1]*8"  
  bd $ "0  ~ ~ 0? ~@4. [~ 0] 0 ~ [~ 0]"
  -- d3 $ fast 2 $ n "~ 0 0 ~"
  mt
    $ fast 2
    $ sometimesBy "^plink" (# (octave (5 |+ irand 3) # sus 4))
    $ (note . cat)
    -- $ (note . cat . fmap (k 0) . fmap (rarely (|+ ("[1 0@3]*4" |* (irand 8) |- 4))))
    (
      fmap (k 0) [
      "2 4 5 [2|-1] 4 0 4 5"
    , "6 8 9 6 8 -4 -2 -1"
    , "1 2 3 1 2 -1 1 2"
    ] ++ fmap (k 1) [
      "[0 1 2 0 1 -2 1 2 | 0 1 2 3 6 5 3 2]"
    ])
    # sus 1.4
    # amp 0.5
  lt
    $ fast 2
    $ (note . cat)
      ([ k 0 "0(3,8)"
      , k 0 "[~@2 0 ~@2 0 ~@2 | [0 ~] [-3 ~] [0 ~] ~]"
      , k 0 $ "0(3,8)" |+ 1
      , k 1 "~@2 0 ~@2 4 ~@2"
      ]
    )
    -- # midibend "0"
    -- # octave 3
    # sus 0.1
    # amp 0.8

all $ id

do
  -- @name steal
  hush
  bd $ n "0  ~ ~ 0? ~@4. [~ 0] 0 ~ [~ 0]"
  sd $ n "[~ [0@3 0??]]*2" # amp 0.6
  oh $ sometimes (chop 2) $ degrade (n "0*16") # amp (range 0.01 0.05 $ rand)
  ch $ fast 8 $ n "0*2" # amp "0.1 0.01"
  -- trm 4 $ trn
  ht
    $ note
    -- $ (|- 12)
     $ (fast 2 . cat)
       [ k 0 $ "~ 6 9 5 . 8 6 4 2"
       , k 0 $ "~ 1 ~ [6, ~@2 3@3,~@3 1@2]@5"
       , k 0 $ "[~ 0 ~ [5, ~@2 2@3,~@3 0@2]@5]"
       , k 1 $ "[~ 0 ~ [5, ~@2 2@3,~@3 -1@2]@5]" |- 4 |+ 7
       , k 0 $ "~ 6 9 5 . 8 6 4 2"
       , k 0 $ "~ 1 ~ [6, ~@2 3@3,~@3 1@2]@5"
       , k 0 $ press $ "2 4 5 6"
       , k 0 $ press $ "2 4 5 6" |+ 7
      ]
  mm $ fast 2
    $ stack [
      -- midibend $ (slow 8 $ struct "t*128" $ (range 0 8192 $ sine)),
      (note . cat)
      ([ k 0 $ "~ 6 9 5 . 8 6 4 2"
       , k 0 $ "~ 1 ~ [6, ~@2 3@3,~@3 1@2]@5"
       , k 0 $ "[~ 0 ~ [5, ~@2 2@3,~@3 0@2]@5]"
       , k 1 $ "[~ 0 ~ [5, ~@2 2@3,~@3 -1@2]@5]" |- 4
       , k 0 $ "~ 6 9 5 . 8 6 4 2"
       , k 0 $ "~ 1 ~ [6, ~@2 3@3,~@3 1@2]@5"
       , k 0 $ press $ "2 4 5 6"
       , k 0 $ press $ "2 4 5 6" |+ 7
       ])
    # amp 0.4
    # sus 2]
  reface
      $ fast 2
      $ n
      $ cat
      (
        fmap (k 0) [
        "2 4 5 [2|-1] 4 0 4 5"
      , "6 8 9 6 8 -4 -2 -1"
      , "1 2 3 1 2 -1 1 2"
      ] ++ fmap (k 1) [
        "[0 1 2 0 1 -2 1 2 | 0 1 2 3 6 5 3 2]"
      ])
      -- |+ 12
  lt
    $ n
    $ fast 2
    $ cat
      ([ k 0 "0(3,8)"
      , k 0 "[~@2 0 ~@2 0 ~@2 | [0 ~] [-3 ~] [0 ~] ~]"
      , k 0 $ "0(3,8)" |+ 1
      , k 1 "~@2 0 ~@2 4 ~@2"
      ]
    )

hush

do
  -- @name end
  sd silence
  ch silence 
  setF "plink"  0.3

hush

do
  hush
  rs $ "0*4"


    bd = bd
    sd = sd
    lt = d3
    mt = d4
    ht = d5
    rs = d6
    hc = d7
    ch = ch
    oh = d9
    cc = bd0
    rc = bd1


sd = tr 1

tr idx pat = p (toID $ "tr8s" ++ show (tr8sToneCCArray!!idx))
      $ pat
      # stack [ s "tr" # midichan 9 # midinote (tr8sChanArray!!idx) , s "loopback" # midichan (pure $ fromIntegral idx) ]

hush


let withLoopback channel pat = stack [ pat, pat # s "loopback" # midichan channel ]
    mm pat = p "mm" $ withLoopback 11 $ pat # s "mm" # midichan 15
    reface pat = p "reface" $ withLoopback 12 $ pat # s "reface" # midichan 0





do
  setkey' 0 "0" "major"
  -- resetCycles
  bd $ fast 2 "0@3 0"
  sd $ fast 2 "~ 0"

  p "mm"
  -- mm
    -- $ trigger "mm"
    -- $ jumpIn'
    -- $ seqPLoop [
    --   (0, 2, nok 0 "0 1 2 3"),
    --   (2, -1, nok 0 "2 0 1 ~")
    -- ]
    $ lock 1 0
    $ nok 0 ("0*8" |+ irand 9)
    # s "mm" # midichan 15 # orbit 0
    # octave 4

-- Freeze a random part
lock n offset = timeLoop n . (offset <~)

resetCycles

p "mm" $ nok 0 ("0*4" |+ irand 4)


  p "mm" $ nok 0 "[0 2 4 6]*2" # s "mm" # midichan 15 # orbit 0

mm $ nok 0 "0"


let myinst instID = p instID . (#) note 0

hush

-- ArrangementPart
-- newtype Instrument a = P (a -> a)  -- function object
-- mkInstrument :: Num a => [a] -> Instrument a  -- constructor

let mmjump n pat = jumpIn' "mm" n $ pat # s "mm" # midichan 15 # orbit 0
    mm [(t1,p1), (t2,p2)] =
      do
        mmjump (t1 + t2) p2
        mmjump t1 $ qtrigger "mm" p1
    intro num part rest = [(1, part), (num, rest)]
    -- hold num ():rest = 
in mm
  $ intro 1 (nok 0 "[-3 0 2 6]*2" + note "0 12" # sus 0.05)
  $ nok 0 "0 ~@4 0 ~@2"
  # octave 4





-- years later... proper tonality
let applyModality pat = pat # note (root +| scale mode notOrig) # 
                        where root = floor $ get "root" pat
                              mode = floor $ get "note" pat
                              noteOrig = floor $ get "note" pat
    mm pat = p "mm" 
    root = pI "root"
    mode = pS "mode"
    key = grp [root, mode]
in mm
    $ sometimes (# key "0:minor")
    $ note "0 2 4 6"
    # key "2:major"


hush




-- Knobs
import Sound.Tidal.ID (fromID)

let mapShuffle = sometimesBy (cF0 "shuffle_chance") (shuffle $ select (cF0 "shuffle_depth") $ take 6 $ iterate (* 2) 2)
    mapChop = sometimesBy (cF0 "chop_chance") (chop $ select (cF0 "chop_depth") $ take 4 $ iterate (* 2) 2)
    mapAmp idx = (|* amp (cF 1 $ (fromID idx) ++ "_amp"))
    chan idx = p idx . mapAmp idx
    mm pat = chan "mm" $ pat # s "mm" # orbit 0 # midichan 15
    -- mm pat = p "mm" $ pat # s "mm" # orbit 0 # midichan 15
    -- solo = id
    -- p = chan

in

do
  all $ slow 2
  
  
  all $ fast 1
    . mapShuffle
    . mapChop
    . byacc (chop 2 . shuffle "[1 16]*2")


setF "mm_amp" 1

    mm
      $ (stack . fmap (nok 0))
      [ "0*16" |+ irand 8
      , "0~0~~0~0~0~0~~0~" |+ "[0,2,4,6]" |- 7
      ]

setkey' 0 0 "major"

-- apparently fills up the scheduler. try creating a wrapper, and then using to replace the key function
let knobkey = setkey' 0 (select (cF 0.5 "root_knob") $ roots) (select (cF0 "key_knob") $ keys)
                where list = [(0, "major")]
                      roots = fmap pure [-12..12]
                      keys = ["phrygian", "minor", "dorian", "mixolydian", "major", "lydian", "locrian"]




do
  setkey' 0 ("d" - 12) "<dorian dorian minor minor>/2"
  mm $ nok 0 ("[<7 7 5 4>/2 <4 5>/2 <2 3>/2 <0 0 -2 -3>/2]")
  reface $ nok 0 "[<[7 4 2 0]!2 [7 5 3 0]!2 [4 2 0 -2]!2 [3 1 -1 -3]!2>/2]*2"
    -- $ "0" |+ "[[-7,0],<[2,4] [3,5]>]/2"

do
  sd $ stack ["[~ . 0 . ~ 0 ~ ~ . 0]/2" # amp "0.25 0.4", "[~ 0]*4" # amp 0.1]

  hush




lt $ nok 0 "0 <~ 0> <~ 0> 0 ~ ~ 0 ~" # amp 0.5 |+ note "<0 [0@3 -4] -6 [-8 . -10 -5]>/4"

lt $ nok 0 "0 <~ 0> <~ 0> 0 ~ ~ 0 ~" # amp 0.5

mm $ (nok 0 . gs trshuf 0.4) ["0*8", "6 -3 0 1 2 0 4 0", "-3*8" |+ irand 10]
  # sus 0.01
  |+ note "<0 [0@3 -4] -6 [-8 . -10 -5]>/4"

mm $ (nok 0 . gs trshuf 0.4) ["0*8", "6 -3 0 1 2 0 4 0", "-3*8" |+ irand 10]


-- MOVE TO BOOT: functions to control tidal with OSC App + wrapper for doing solos
let slider n = cF0 ("slider" ++ show n)
    gsrange mean dev range = gs mean dev $ fmap pure range
    slidersolo slidera sliderb top = gsrange (slider slidera) (slider sliderb) [0..top]
    bySlider x f = f (slider x)

hush

ht $ degradeBy (slider 3) $ nok 0 ("0*16" |+ slidersolo 1 2 10)

setkey' 0 0 "lydian"


ht $ nok 0 "0*8"

-- bd $ n "0*8" # amp "^slider1"
bd $ degradeBy (slider 4) $ n "0*8" 